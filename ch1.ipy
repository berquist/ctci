import numpy as np

np.set_printoptions(linewidth=200)


def ch1_1_1(s):
    ss = set()
    for c in s:
        ss.add(c)
    if len(ss) < len(s):
        return False
    return True

def ch1_1_2(s):
    ss = set()
    for c in s:
        if c not in ss:
            ss.add(c)
        else:
            return False
    return True

def ch1_1_3(s):
    ss = sorted(s)
    lss = len(ss)
    if lss == 1:
        return True
    for i in range(1, lss):
        if ss[i] == ss[i - 1]:
            return False
    return True

s1 = 'abcddaasdfh'
s2 = 'abcdefgh'
assert not ch1_1_1(s1)
assert not ch1_1_2(s1)
assert not ch1_1_3(s1)
assert ch1_1_1(s2)
assert ch1_1_2(s2)
assert ch1_1_3(s2)

# %timeit ch1_1_1(s1)
# %timeit ch1_1_2(s1)
# %timeit ch1_1_3(s1)
# %timeit ch1_1_1(s2)
# %timeit ch1_1_2(s2)
# %timeit ch1_1_3(s2)

def ch1_2_1(s1, s2):
    if len(s1) != len(s2):
        return False
    ss1 = sorted(s1)
    ss2 = sorted(s2)
    if ss1 != ss2:
        return False
    return True

# there is also a solution that uses a hash table to store frequencies

assert not ch1_2_1(s1, s2)
assert ch1_2_1(s1, s1)
assert ch1_2_1(s2, s2[::-1])

def ch1_3_1(s):
    return s.rstrip().replace(' ', '%20')

def ch1_4_1(s):
    # forgot this...
    s = s.lower().replace(' ', '')
    frequencies = dict()
    for c in s:
        if c not in frequencies:
            frequencies[c] = 1
        else:
            frequencies[c] += 1
        if frequencies[c] > 2:
            return False
    values = frequencies.values()
    # c1 = values.count(1)
    c1 = list(values).count(1)
    if c1 > 1:
        return False
    # c2 = values.count(2)
    c2 = list(values).count(2)
    # if (c1 + c2) != len(s):
    if (c1 + 2 * c2) != len(s):
        return False
    return True

# 1. forgot to lower case and remove spaces
# 2. dict_values doesn't have a count method
# 3. forgot that characters with frequency 2 count twice to length

assert ch1_4_1('Tact Coa')

# does this run in O(N) time?
# use a bit vector?

def ch1_5_1(s1, s2):
    l1, l2 = len(s1), len(s2)
    if abs(l1 - l2) > 1:
        return False
    if s1 == s2:
        return True
    # index = 0
    index = -1
    # removal
    if l2 == (l1 - 1):
        # for i in range(l1):
        for i in range(l2):
            if s1[i] != s2[i]:
                index = i
                break
        sr1 = s1[index + 1:]
        sr2 = s2[index:]
        if index == -1:
            return True
        if sr1 != sr2:
            return False
        return True
    # insertion
    elif l2 == (l1 + 1):
        # for i in range(l2):
        for i in range(l1):
            if s1[i] != s2[i]:
                index = i
                break
        sr1 = s1[index:]
        sr2 = s2[index + 1:]
        if index == -1:
            return True
        if sr1 != sr2:
            return False
        return True
    # replacement
    else:
        for i in range(l1):
            if s1[i] != s2[i]:
                index = i
                break
        # sr1 = s1[index:]
        # sr2 = s2[index:]
        sr1 = s1[index + 1:]
        sr2 = s2[index + 1:]
        if index == -1:
            return True
        if sr1 != sr2:
            return False
        return True

def ch1_5_2(s1, s2):
    l1, l2 = len(s1), len(s2)
    if abs(l1 - l2) > 1:
        return False
    if s1 == s2:
        return True
    index = -1
    if l2 == (l1 - 1):
        lr, il1, il2 = l2, 1, 0
    elif l2 == (l1 + 1):
        lr, il1, il2 = l1, 0, 1
    else:
        lr, il1, il2 = l1, 1, 1
    for i in range(lr):
        if s1[i] != s2[i]:
            index = i
            break
    if index == -1:
        return True
    sr1 = s1[index + il1:]
    sr2 = s2[index + il2:]
    if sr1 != sr2:
        return False
    return True

tests = [
    ('pale', 'ple', True),
    ('pales', 'pale', True),
    ('pale', 'bale', True),
    ('pale', 'bake', False),
]

for (s1, s2, outcome) in tests:
    assert ch1_5_1(s1, s2) == outcome
    assert ch1_5_2(s1, s2) == outcome

def ch1_6_1(s):
    ls = len(s)
    if ls == 1:
        return s
    pairs, count, curr, prev = [], 1, '', ''
    for i in range(1, ls):
        curr = s[i]
        prev = s[i - 1]
        if prev != curr:
            pairs.append((prev, count))
            count = 0
        count += 1
    pairs.append((curr, count))
    ns = ''.join(['{}{}'.format(c, str(count)) for (c, count) in pairs])
    if len(ns) > ls:
        return s
    return ns

s = 'aabcccccaaa'
ns = 'a2b1c5a3'
assert ch1_6_1(s) == ns


def ch1_7_1(mat):
    nr, nc = mat.shape
    assert nr == nc
    for i in range(nr):
        for j in range(i):
            # Pythonic way
            mat[i, j], mat[j, i] = mat[j, i], mat[i, j]
            # non-Pythonic way
            # eij = mat[i][j]
            # mat[i][j] = mat[j][i]
            # mat[j][i] = eij
    return


mat = np.array([[1, 2, 3],
                [4, 5, 6],
                [7, 8, 9]])
mat_t = np.array([[1, 4, 7],
                  [2, 5, 8],
                  [3, 6, 9]])
ch1_7_1(mat)
assert np.all(mat == mat_t)


def find_zero_indices(mat, thresh=1.0e-15):
    nr, nc = mat.shape
    zero_index_pairs = []
    for i in range(nr):
        for j in range(nc):
            if abs(mat[i, j]) < thresh:
                zero_index_pairs.append((i, j))
    return zero_index_pairs


def ch1_8_1(mat):
    """zero_matrix"""
    nr, nc = mat.shape
    zero_index_pairs = find_zero_indices(mat)
    zrows = set([pair[0] for pair in zero_index_pairs])
    zcols = set([pair[1] for pair in zero_index_pairs])
    for ir in zrows:
        for ic in range(nc):
            mat[ir, ic] = 0
    for ic in zcols:
        for ir in range(nr):
            mat[ir, ic] = 0
    return


dim = 10
a = np.random.random((dim, dim))
b = a.copy()
# print(a)
a[4, 5] = 0
a[4, 7] = 0
b[4, :] = 0
b[:, 5] = 0
b[:, 7] = 0
# print(a)
# print(b)
ch1_8_1(a)
# print(a)
assert np.all(a == b)


def ch1_9_1(parent, rotated):
    """string_rotation"""
    doubled = rotated + rotated
    index = doubled.find(parent)
    if index > -1:
        return True
    return False

s1 = 'waterbottle'
s2 = 'erbottlewat'
s3 = 'erbottlewaf'
assert ch1_9_1(s1, s2)
assert not ch1_9_1(s1, s3)
